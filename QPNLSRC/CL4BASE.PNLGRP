:pnlgrp.

.* 01
:help name=m0option1.
Opzione 1: Solo "PGM"
:xh3.Opzione 1: Solo "PGM"
:p.
Un sorgente contenente la sola istruzione PGM compila comunque con 
successo e può dar vita ad un programma a tutti gli effetti.
:xmp.
PGM
:exmp.
:ehelp.

.* 02
:help name=m0option2.
Opzione 2: Con "SNDPGMMSG"
:xh3.Opzione 2: Con "SNDPGMMSG"
:p.
Il sorgente si apre con PGM e chiude con ENDPGM e presenta la sola istruzione efficace SNDPGMMSG.
Che emetterà appunto un messaggio ("Ciao ILE CL Boomers e non!").
:xmp.
PGM
SNDPGMMSG MSG('Ciao ILE CL Boomers e non!')
ENDPGM
:exmp.
:ehelp.

.* 03
:help name=m0option3.
Opzione 3: Messaggio basato sul parametro
:xh3.Opzione 3: Messaggio basato sul parametro
:p.
Il sorgente si apre con PGM PARM(&AMP.NOMEFILE) 
e il messaggio viene costruito di conseguenza: SNDPGMMSG MSG(&AMP.NOMEFILE).
:xmp.
PGM      PARM(&NOMEFILE)
DCL       VAR(&NOMEFILE) TYPE(*CHAR) LEN(30)
SNDPGMMSG MSG(&NOMEFILE)
DMPCLPGM
ENDPGM
:exmp.
:ehelp.

.* 04
:help name=m0option4.
Opzione 4: Terminato con NULL
:xh3.Opzione 4: Terminato con NULL
:p.
Rimossi gli spazi finali della variabile &amp.NOMEFILE concateniamo
la variabile &amp.NULL inizilizzata con l'esadecimale 00.
Così costruiamo una stringa "null-terminated".
Il dump CL ottenuto con la "DMPCLPGM" consente la verifica.
:xmp.
PGM      PARM(&NOMEFILE)
DCL       VAR(&NOMEFILE) TYPE(*CHAR) LEN(30)
DCL       VAR(&NULL)     TYPE(*CHAR) LEN(1)  VALUE(X'00')
CHGVAR    VAR(&NOMEFILE) VALUE(&NOMEFILE *TCAT &NULL)
SNDPGMMSG MSG(&NOMEFILE)
DMPCLPGM
ENDPGM
:exmp.
:ehelp.

.* 05
:help name=m0option5.
Opzione 5: Con "CALLPRC" di stat() 
:xh3.Opzione 5: Con "CALLPRC" di stat() 
:p.
Primo esempio di chiamata ad una API della libreria standard C, stat(), che 
restituisce informazioni su un file riempiendo un blocco 
passato dal chiamante. 
Il nomefile è null-terminated giusto prima della invocazione.
Il dump CL ottenuto con la "DMPCLPGM" consente la verifica.
:xmp.
PGM       PARM(&NOMEFILE)
DCL        VAR(&NOMEFILE) TYPE(*CHAR) LEN(30)
DCL    VAR(&NULL)         TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL    VAR(&BUFFER)       TYPE(*CHAR) LEN(128)
CHGVAR     VAR(&NOMEFILE) VALUE(&NOMEFILE *TCAT &NULL)
SNDPGMMSG  MSG(&NOMEFILE)
CALLPRC PRC('stat') PARM(&NOMEFILE &BUFFER)
DMPCLPGM
ENDPGM
:exmp.
:ehelp.

.* 06
:help name=m0option6.
Opzione 6: Con campi della struct  
:xh3.Opzione 6: Con campi della struct  
:p.
Affinamento della chiamata alla stat(): mediante variabili STG(*DEFINED)
il contenuto del blocco dati viene interpretato secondo la struttura
descritta dal linguaggio C.
:xmp.
PGM PARM(&NOMEFILE)
DCL VAR(&NOMEFILE)    TYPE(*CHAR) LEN(30)
DCL VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL VAR(&STAT_BUF)    TYPE(*CHAR) LEN(128)
DCL VAR(&S01_MODE)    TYPE(*UINT) LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF   1) 
DCL VAR(&S02_INO)     TYPE(*UINT) LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF   5) 
DCL VAR(&S03_NLINK)   TYPE(*UINT) LEN(2)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF   9) 
DCL VAR(&S04_UID)     TYPE(*UINT) LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF  13) 
DCL VAR(&S05_GID)     TYPE(*UINT) LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF  17) 
DCL VAR(&S06_SIZE)    TYPE(*INT)  LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF  21)
DCL VAR(&S07_ATIME)   TYPE(*INT)  LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF  25)
DCL VAR(&S08_MTIME)   TYPE(*INT)  LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF  29)
DCL VAR(&S09_CTIME)   TYPE(*INT)  LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF  33)
DCL VAR(&S10_DEV)     TYPE(*UINT) LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF  37)
DCL VAR(&S11_BLKSZE)  TYPE(*UINT) LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF  41)
DCL VAR(&S12_ALLSZE)  TYPE(*UINT) LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF  45)
DCL VAR(&S13_OBJTYP)  TYPE(*CHAR) LEN(10) STG(*DEFINED) +
 DEFVAR(&STAT_BUF  49)
DCL VAR(&S14_CDEPAG)  TYPE(*UINT) LEN(2)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF  61) 
DCL VAR(&S15_GENID)   TYPE(*UINT) LEN(4)  STG(*DEFINED) +
 DEFVAR(&STAT_BUF 125)
CHGVAR VAR(&NOMEFILE) VALUE(&NOMEFILE *TCAT &NULL)
CALLPRC PRC('stat') PARM(&NOMEFILE &STAT_BUF)
DMPCLPGM
ENDPGM
:exmp.
:ehelp.

.* 07
:help name=m0option7.
Opzione 7: Messaggio con campi
:xh3.Opzione 7: Messaggio con campi
:p.
L'indagine mediante "DMPCLPGM" termina: ora una selezione dei campi
di interesse restituiti dalla stat() viene composta in un 
messaggio.
:xmp.
PGM     PARM(&NOMEFILE)
DCL     VAR(&NOMEFILE)    TYPE(*CHAR) LEN(30)
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
INCLUDE SRCSTMF('STAT.CLLE')
DCL     VAR(&MESSAGGIO)   TYPE(*CHAR) LEN(80)
CHGVAR  VAR(&MESSAGGIO) VALUE('Il file <' *CAT &NOMEFILE)
CHGVAR  VAR(&NOMEFILE)  VALUE(&NOMEFILE *TCAT &NULL)
CALLPRC PRC('stat') PARM(&NOMEFILE &STAT_BUF)
CHGVAR VAR(&MESSAGGIO) VALUE(&MESSAGGIO *TCAT '>, di tipo' +
                 *BCAT &S13_OBJTYP +
                 *TCAT ', utilizza' +
                 *BCAT %CHAR(&S06_SIZE) +
                 *BCAT 'bytes')
SNDPGMMSG MSG(&MESSAGGIO)
ENDPGM
:exmp.
:ehelp.

.* 08
:help name=m0option8.
Opzione 8: Con subroutine per altre API
:xh3.Opzione 8: Con subroutine per altre API
:p.
Si introducono due nuove chiamate C: localtime() e strftime()
invocate all'interno di una subroutine CL. L'uso della "CALLSUBR"
consente di evitare la ripetizione di righe di codice.
Purtroppo la SUBR 
:link perform='DSPHELP M0OPTION9'.
non supporta 
:elink.
il passaggio parametri.
:xmp.
PGM PARM(&NOMEFILE)
DCL VAR(&NOMEFILE)    TYPE(*CHAR) LEN(30)
DCL VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
INCLUDE SRCSTMF('STAT.CLLE')
DCL VAR(&MESSAGGIO)   TYPE(*CHAR) LEN(80)
DCL VAR(&ANYTIME)     TYPE(*INT)  LEN(4) 
DCL VAR(&TM_PTR)      TYPE(*PTR)  ADDRESS(*NULL) 
DCL VAR(&QUANDO)      TYPE(*CHAR) LEN(80)
DCL VAR(&QUALEN)      TYPE(*INT)  LEN(4)   VALUE(80) 
DCL VAR(&STILE)       TYPE(*CHAR) LEN(21) +
 VALUE('%A, %d %b %Y alle %T')
DCL VAR(&COUNT)       TYPE(*INT)  LEN(4)   
CHGVAR VAR(&STILE) VALUE(&STILE *TCAT &NULL)
CHGVAR VAR(&MESSAGGIO) VALUE('Il file <' *CAT &NOMEFILE)
CHGVAR VAR(&NOMEFILE) VALUE(&NOMEFILE *TCAT &NULL)
CALLPRC PRC('stat') PARM(&NOMEFILE &STAT_BUF)
CHGVAR VAR(&MESSAGGIO) VALUE(&MESSAGGIO *TCAT '>, di tipo' +
                      *BCAT &S13_OBJTYP *TCAT ', utilizza' +
                      *BCAT %CHAR(&S06_SIZE) *BCAT 'bytes')
SNDPGMMSG MSG(&MESSAGGIO)
CHGVAR VAR(&MESSAGGIO) VALUE('Ultimo accesso')
CHGVAR VAR(&ANYTIME) VALUE(&S07_ATIME)
CALLSUBR SUBR(FORMATTA)
CHGVAR VAR(&MESSAGGIO) +
     VALUE(&MESSAGGIO *BCAT %SST(&QUANDO 1 &COUNT))
SNDPGMMSG MSG(&MESSAGGIO)
CHGVAR VAR(&MESSAGGIO) VALUE('Ultima modifica')
CHGVAR VAR(&ANYTIME) VALUE(&S08_MTIME)
CALLSUBR SUBR(FORMATTA)
CHGVAR VAR(&MESSAGGIO) +
     VALUE(&MESSAGGIO *BCAT %SST(&QUANDO 1 &COUNT))
SNDPGMMSG MSG(&MESSAGGIO)
CHGVAR VAR(&MESSAGGIO) VALUE('Ultimo cambiamento di stato')
CHGVAR VAR(&ANYTIME) VALUE(&S09_CTIME)
CALLSUBR SUBR(FORMATTA)
CHGVAR VAR(&MESSAGGIO) +
     VALUE(&MESSAGGIO *BCAT %SST(&QUANDO 1 &COUNT))
SNDPGMMSG MSG(&MESSAGGIO)
SUBR SUBR(FORMATTA)
  CALLPRC PRC('localtime') PARM(&ANYTIME) RTNVAL(&TM_PTR) 
  CALLPRC PRC('strftime') +
    PARM( &QUANDO (&QUALEN *BYVAL) &STILE (&TM_PTR *BYVAL)) +
    RTNVAL(&COUNT)     
ENDSUBR
ENDPGM
:exmp.
:ehelp.

.* 09
:help name=M0OPTION9.
Opzione 9: Supporto ideale (non c'è)
:xh3.Opzione 9: Supporto ideale (non c'è)
:p.
Idealmente una subroutine potrebbe agire come una funzione
definita localmente in cui le variabili passate come argomento
e variabili definite al suo interno avessero scoping distinti.
:xmp.
PGM
  DCL VAR(&QUANDO)      TYPE(*CHAR) LEN(80)
  DCL VAR(&QUALEN)      TYPE(*INT)  LEN(4) 
  DCL VAR(&STILE)       TYPE(*CHAR) LEN(20) VALUE('%A, %d %b %Y alle %T')
  DCL VAR(&COUNT)       TYPE(*INT)  LEN(4) 
  SUBR SUBR(FORMATTA) PARM(&ANYTIME)
    DCL VAR(&ANYTIME) TYPE(*INT)  LEN(4) 
    DCL VAR(&TM_PTR)  TYPE(*PTR)  ADDRESS(*NULL)   
    CALLPRC PRC('localtime') PARM(&ANYTIME) RTNVAL(&TM_PTR)
    CALLPRC PRC('strftime')  PARM(&QUANDO (&QUALEN *BYVAL) &STILE (&TM_PTR *BYVAL)) RTNVAL(&COUNT)     
  ENDSUBR
ENDPGM
:exmp.
:ehelp.

.* 10
:help name=m0option10.
Opzione 10: Funzione specializzata
:xh3.Opzione 10: Funzione specializzata
:p.
Questo codice ILE CL, una volta compilato, costituisce una funzione 
resa disponibile in un modulo agganciabile tramite "CALLPRC".
Il timestamp ricevuto nel parametro &amp.ANYTIME viene convertito
e formattato secondo la specifica in &amp.STILE.
L'esito è restituito nella variabile &amp.QUANDO. 
:xmp.
PGM PARM(&ANYTIME &QUANDO)
  DCL VAR(&ANYTIME)  TYPE(*INT)  LEN(4) 
  DCL VAR(&QUANDO)   TYPE(*CHAR) LEN(80)
  DCL VAR(&STILE)    TYPE(*CHAR) LEN(21) +
                 VALUE('%A, %d %b %Y alle %T')
                     /* 12345678901234567890 */ 
  DCL VAR(&COUNT)    TYPE(*INT)  LEN(4)  
  DCL VAR(&NULL)     TYPE(*CHAR) LEN(1)  VALUE(X'00')
  DCL VAR(&QUALEN)   TYPE(*INT)  LEN(4)  VALUE(80)
  DCL VAR(&TM_PTR)   TYPE(*PTR)  ADDRESS(*NULL)
  CHGVAR VAR(&STILE) VALUE(&STILE *TCAT &NULL)
  CALLPRC PRC('localtime') PARM(&ANYTIME) RTNVAL(&TM_PTR) 
  CALLPRC PRC('strftime') +
    PARM(&QUANDO (&QUALEN *BYVAL) &STILE (&TM_PTR *BYVAL)) +
    RTNVAL(&COUNT) 
  CHGVAR VAR(&QUANDO) VALUE(%SST(&QUANDO 1 &COUNT))
ENDPGM
:exmp.
:ehelp.

.* 11
:help name=m0option11.
Opzione 11: Strutturato in 2 moduli ILE CL
:xh3.Opzione 11: Strutturato in 2 moduli ILE CL
:p.
La particolarità è la ripetuta invocazione della API "CL4B_010" implementata
in 
:link perform='DSPHELP M0OPTION10'.
un modulo
:elink.
a parte. Il primo argomento viene passato direttamente nella chiamata. 
Nei tre casi assume rispettivamente il valore di campi diversi della struttura
restituita dalla stat().
:xmp.
PGM PARM(&NOMEFILE)
  DCL VAR(&NOMEFILE)    TYPE(*CHAR) LEN(30)
  DCL VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
  INCLUDE SRCSTMF('STAT.CLLE')
  DCL VAR(&MESSAGGIO)   TYPE(*CHAR) LEN(80)
  DCL VAR(&QUANDO)      TYPE(*CHAR) LEN(80)
  CHGVAR VAR(&MESSAGGIO) VALUE('Il file <' *CAT &NOMEFILE)
  CHGVAR VAR(&NOMEFILE) VALUE(&NOMEFILE *TCAT &NULL)
  CALLPRC PRC('stat') PARM(&NOMEFILE &STAT_BUF)
  CHGVAR VAR(&MESSAGGIO) VALUE(&MESSAGGIO *TCAT +
                              '>, di tipo' *BCAT +
                              &S13_OBJTYP *TCAT +
                              ', utilizza' *BCAT +
                              %CHAR(&S06_SIZE) *BCAT +
                              'bytes')
  SNDPGMMSG MSG(&MESSAGGIO)
  CHGVAR VAR(&MESSAGGIO) VALUE('Ultimo accesso')
  CALLPRC PRC('CL4B_010') PARM(&S07_ATIME &QUANDO)
  CHGVAR VAR(&MESSAGGIO) VALUE(&MESSAGGIO *BCAT &QUANDO)
  SNDPGMMSG MSG(&MESSAGGIO)
  CHGVAR VAR(&MESSAGGIO) VALUE('Ultima modifica')
  CALLPRC PRC('CL4B_010') PARM(&S08_MTIME &QUANDO)
  CHGVAR VAR(&MESSAGGIO) VALUE(&MESSAGGIO *BCAT &QUANDO)
  SNDPGMMSG MSG(&MESSAGGIO)
  CHGVAR VAR(&MESSAGGIO) VALUE('Ultimo cambiamento di stato')
  CALLPRC PRC('CL4B_010') PARM(&S09_CTIME &QUANDO)
  CHGVAR VAR(&MESSAGGIO) VALUE(&MESSAGGIO *BCAT &QUANDO)
  SNDPGMMSG MSG(&MESSAGGIO)
ENDPGM
:exmp.
:ehelp.

.* 12
:help name=m0option12.
Opzione 12: Introduco il tipo *PTR
:xh3.Opzione 12: Introduco il tipo *PTR
:p.
Simile al precente ma col passaggio della variabile &amp.STAT_BUF_P
nella modalità *BYVAL (anzichè direttamente la &amp.STAT_BUF *BYREF).
Il risultato è lo stesso ma offre lo spunto per una diversa definizione
del file coinvolto dall'INCLUDE.
:xmp.
PGM PARM(&NOMEFILE)
  DCL VAR(&NOMEFILE)    TYPE(*CHAR) LEN(30)
  DCL VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
  INCLUDE SRCSTMF('STAT.CLLE')
  DCL VAR(&STAT_BUF_P)  TYPE(*PTR)  ADDRESS(&STAT_BUF)
  DCL VAR(&MESSAGGIO)   TYPE(*CHAR) LEN(80)
  DCL VAR(&QUANDO)      TYPE(*CHAR) LEN(80)
  CHGVAR VAR(&MESSAGGIO) VALUE('Il file <' *CAT &NOMEFILE)
  CHGVAR VAR(&NOMEFILE) VALUE(&NOMEFILE *TCAT &NULL)
  CALLPRC PRC('stat') PARM(&NOMEFILE (&STAT_BUF_P *BYVAL))
  CHGVAR VAR(&MESSAGGIO) VALUE(&MESSAGGIO *TCAT +
                              '>, di tipo' *BCAT +
                              &S13_OBJTYP *TCAT +
                              ', utilizza' *BCAT +
                              %CHAR(&S06_SIZE) *BCAT +
                              'bytes')
  SNDPGMMSG MSG(&MESSAGGIO)
  CHGVAR VAR(&MESSAGGIO) VALUE('Ultimo accesso')
  CALLPRC PRC('CL4B_010') PARM(&S07_ATIME &QUANDO)
  CHGVAR VAR(&MESSAGGIO) VALUE(&MESSAGGIO *BCAT &QUANDO)
  SNDPGMMSG MSG(&MESSAGGIO)
  CHGVAR VAR(&MESSAGGIO) VALUE('Ultima modifica')
  CALLPRC PRC('CL4B_010') PARM(&S08_MTIME &QUANDO)
  CHGVAR VAR(&MESSAGGIO) VALUE(&MESSAGGIO *BCAT &QUANDO)
  SNDPGMMSG MSG(&MESSAGGIO)
  CHGVAR VAR(&MESSAGGIO) VALUE('Ultimo cambiamento di stato')
  CALLPRC PRC('CL4B_010') PARM(&S09_CTIME &QUANDO)
  CHGVAR VAR(&MESSAGGIO) VALUE(&MESSAGGIO *BCAT &QUANDO)
  SNDPGMMSG MSG(&MESSAGGIO)
ENDPGM
:exmp.
:ehelp.

.* 13
:help name=m0option13.
Opzione 13: Strutturato in 3 moduli ILE CL
:xh3.Opzione 13: Strutturato in 3 moduli ILE CL
:p.
La strutturazione in moduli procede: ora sono 3. Il nuovo 
:link perform='DSPHELP M0OPTION14'.
componente intermedio
:elink.
personalizza la eleaborazione dei campi della struttura restituita
dalla stat() ed estesa per poter raccogliere messaggi su più livelli.
:xmp.
PGM PARM(&NOMEFILE)
  DCL VAR(&NOMEFILE)    TYPE(*CHAR) LEN(30)
  DCL VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
  DCL VAR(&BUFFER)      TYPE(*CHAR) LEN(1280)
  DCL VAR(&MESSAGGIO1)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  129)
  DCL VAR(&MESSAGGIO2)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  257)
  DCL VAR(&MESSAGGIO3)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  385)
  DCL VAR(&MESSAGGIO4)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  513)
  DCL VAR(&STAT_BUF_P)  TYPE(*PTR)  ADDRESS(&BUFFER) 
  INCLUDE SRCSTMF('STAT_P.CLLE')                      
  CHGVAR VAR(&MESSAGGIO1) VALUE('Il file <' *CAT &NOMEFILE)
  CHGVAR VAR(&NOMEFILE) VALUE(&NOMEFILE *TCAT &NULL)
  CALLPRC PRC('stat') PARM(&NOMEFILE (&BUFFER))
  CALLPRC PRC('CL4B_014') PARM((&BUFFER))
  SNDPGMMSG MSG(&MESSAGGIO1)
  SNDPGMMSG MSG(&MESSAGGIO2)                                      
  SNDPGMMSG MSG(&MESSAGGIO3)
  SNDPGMMSG MSG(&MESSAGGIO4)                                      
ENDPGM
:exmp.
:ehelp.

.* 14
:help name=m0option14.
Opzione 14: Modulo intermedio v1
:xh3.Modulo intermedio v1
:p.
Il componente si occupa esclusivamente della predisposizione di
messaggi per i diversi timestamp presenti nel blocco 
restituito dalla stat().
Si serve del
:link perform='DSPHELP M0OPTION10'.
modulo già presentato
:elink.
che ora costituisce il terzo livello di dettaglio.
:xmp.
PGM PARM(&BUFFER)
  DCL VAR(&BUFFER)      TYPE(*CHAR) LEN(1280)
  DCL VAR(&MESSAGGIO1)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  129)
  DCL VAR(&MESSAGGIO2)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  257)
  DCL VAR(&MESSAGGIO3)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  385)
  DCL VAR(&MESSAGGIO4)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  513)
  DCL VAR(&QUANDO)      TYPE(*CHAR) LEN(80)
  DCL VAR(&STAT_BUF_P)  TYPE(*PTR) 
  INCLUDE SRCSTMF('STAT_P.CLLE')
  CHGVAR VAR(&STAT_BUF_P) VALUE(%ADDRESS(&BUFFER))
  CHGVAR VAR(&MESSAGGIO1) VALUE(&MESSAGGIO1 *TCAT '>, di tipo' *BCAT &S13_OBJTYP +
                             *TCAT ', utilizza' *BCAT %CHAR(&S06_SIZE) *BCAT 'bytes')
  CHGVAR VAR(&MESSAGGIO2) VALUE('Ultimo accesso')
  CALLPRC PRC('CL4B_010') PARM(&S07_ATIME &QUANDO)
  CHGVAR VAR(&MESSAGGIO2) VALUE(&MESSAGGIO2 *BCAT &QUANDO)
  CHGVAR VAR(&MESSAGGIO3) VALUE('Ultima modifica')                
  CALLPRC PRC('CL4B_010') PARM(&S08_MTIME &QUANDO)               
  CHGVAR VAR(&MESSAGGIO3) VALUE(&MESSAGGIO3 *BCAT &QUANDO)         
  CHGVAR VAR(&MESSAGGIO4) VALUE('Ultimo cambiamento di stato')    
  CALLPRC PRC('CL4B_010') PARM(&S09_CTIME &QUANDO)               
  CHGVAR VAR(&MESSAGGIO4) VALUE(&MESSAGGIO4 *BCAT &QUANDO)         
                           
ENDPGM
:exmp.
:ehelp.

.* 15
:help name=m0option15.
Opzione 15: Su 3 moduli con più messaggi
:xh3.Opzione 15: Su 3 moduli con più messaggi
:p.
Ora generalizziamo la elaborazione dei messaggi (tutti supposti di lunghezza uguale)
introducendo nella struttura passata alla 
:link perform='DSPHELP M0OPTION16'.
nuova funzione
:elink.
una variabile che specifica il numero stesso dei parametri valorizzati (&amp.&NUMBOFMSGS)
:xmp.
PGM PARM(&NOMEFILE)
  DCL VAR(&NOMEFILE)    TYPE(*CHAR) LEN(30)
  DCL VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
  DCL VAR(&CURRENTMGS)  TYPE(*INT)  LEN(2) 
  DCL VAR(&BUFFER)      TYPE(*CHAR) LEN(1280)
  DCL VAR(&NUMBOFMSGS)  TYPE(*INT)  LEN(2)   STG(*DEFINED) DEFVAR(&BUFFER  129)
  DCL VAR(&MESSAGGI)    TYPE(*CHAR) LEN(800) STG(*DEFINED) DEFVAR(&BUFFER  131)
  DCL VAR(&STAT_BUF_P)  TYPE(*PTR)  ADDRESS(&BUFFER) 
  DCL VAR(&MSG_PTR)     TYPE(*PTR)  ADDRESS(&MESSAGGI)
  DCL VAR(&MESSAGGIO)   TYPE(*CHAR) LEN(80) STG(*BASED) BASPTR(&MSG_PTR)
  INCLUDE SRCSTMF('STAT_P.CLLE')                      
  CHGVAR VAR(&MESSAGGIO) VALUE('Il file <' *CAT &NOMEFILE)
  CHGVAR VAR(&NOMEFILE) VALUE(&NOMEFILE *TCAT &NULL)
  CALLPRC PRC('stat') PARM(&NOMEFILE (&BUFFER))
  CALLPRC PRC('CL4B_016') PARM((&BUFFER))
  DOFOR VAR(&CURRENTMGS) FROM(1) TO(&NUMBOFMSGS) 
    SNDPGMMSG MSG(&MESSAGGIO)
    CHGVAR VAR(%OFFSET(&MSG_PTR)) VALUE(%OFFSET(&MSG_PTR)+80)
  ENDDO
ENDPGM
:exmp.
:ehelp.

.* 16
:help name=m0option16.
Opzione 16: Modulo intermedio v2
:xh3.Opzione 16: Modulo intermedio v2
:p.
Qui cambia il layout della sezione messaggi tutti di lunghezza 80.
Si noti che qui -per comodità- si adottano variabili STG(*DEFINED)
specifiche da referenziale all'interno del codice per i singoli 
messaggi.
:xmp.
PGM PARM(&BUFFER)
  DCL VAR(&BUFFER)      TYPE(*CHAR) LEN(1280)
  DCL VAR(&NUMBOFMSGS)  TYPE(*INT)  LEN(2)  STG(*DEFINED) DEFVAR(&BUFFER  129)
  DCL VAR(&MESSAGGIO1)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  131)
  DCL VAR(&MESSAGGIO2)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  211)
  DCL VAR(&MESSAGGIO3)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  291)
  DCL VAR(&MESSAGGIO4)  TYPE(*CHAR) LEN(80) STG(*DEFINED) DEFVAR(&BUFFER  371)
  DCL VAR(&QUANDO)      TYPE(*CHAR) LEN(80)
  DCL VAR(&STAT_BUF_P)  TYPE(*PTR) 
  INCLUDE SRCSTMF('STAT_P.CLLE')
  CHGVAR VAR(&STAT_BUF_P) VALUE(%ADDRESS(&BUFFER))
  CHGVAR VAR(&MESSAGGIO1) VALUE(&MESSAGGIO1 *TCAT '>, di tipo' *BCAT &S13_OBJTYP +
                             *TCAT ', utilizza' *BCAT %CHAR(&S06_SIZE) *BCAT 'bytes')
  CHGVAR VAR(&MESSAGGIO2) VALUE('Ultimo accesso')
  CALLPRC PRC('CL4B_010') PARM(&S07_ATIME &QUANDO)
  CHGVAR VAR(&MESSAGGIO2) VALUE(&MESSAGGIO2 *BCAT &QUANDO)
  CHGVAR VAR(&MESSAGGIO3) VALUE('Ultima modifica')                
  CALLPRC PRC('CL4B_010') PARM(&S08_MTIME &QUANDO)               
  CHGVAR VAR(&MESSAGGIO3) VALUE(&MESSAGGIO3 *BCAT &QUANDO)         
  CHGVAR VAR(&MESSAGGIO4) VALUE('Ultimo cambiamento di stato')    
  CALLPRC PRC('CL4B_010') PARM(&S09_CTIME &QUANDO)               
  CHGVAR VAR(&MESSAGGIO4) VALUE(&MESSAGGIO4 *BCAT &QUANDO)         
  CHGVAR VAR(&NUMBOFMSGS) VALUE(4)                        
ENDPGM
:exmp.
:ehelp.

.* 17
:help name=m0option17.
Opzione 17: Uso di fopen()/fclose()
:xh3.Opzione 17: Uso di fopen()/fclose()
:p.
Tramite la fopen() riceviamo un blocco dati sipezioonabile tramite
la lettura dello spool file generato con la "DMPCLPGM".
Lo studio della documentazione ci consente di presispore un include
per identificare i singoli campi restituiti.
:xmp.
PGM     PARM(&NOMEFILE)
DCL     VAR(&NOMEFILE)    TYPE(*CHAR) LEN(60)
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&MODE)        TYPE(*CHAR) LEN(11)  VALUE('rb')
DCL VAR(&FILE_BUF_P)  TYPE(*PTR) 
INCLUDE SRCSTMF('FILE_P.CLLE')
CHGVAR  VAR(&NOMEFILE)  VALUE(&NOMEFILE *TCAT &NULL)
CHGVAR  VAR(&MODE)      VALUE(&MODE *TCAT &NULL)
CALLPRC PRC('fopen') PARM(&NOMEFILE &MODE) RTNVAL(&FILE_BUF_P)
DMPCLPGM
CALLPRC PRC('fclose') PARM((&FILE_BUF_P *BYVAL))
ENDPGM
:exmp.
:ehelp.

.* 18
:help name=m0option18.
Opzione 18: Aggiunta della fread()
:xh3.Opzione 18: Aggiunta della fread()
:p.
Tra i campi presenti nella struttura valorizzata con la fopen() si trova &amp.F07_APPRRN
che ci comunica il numero di record: ecco il perchè della "DOFOR". 
:xmp.
PGM     PARM(&NOMEFILE)
DCL     VAR(&NOMEFILE)    TYPE(*CHAR) LEN(60)
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&MODE)        TYPE(*CHAR) LEN(11)  VALUE('rb')
DCL     VAR(&ROW_NO)      TYPE(*INT)  LEN(4)   VALUE(1)
DCL     VAR(&RAW_ROW)     TYPE(*CHAR) LEN(312) 
DCL     VAR(&ROW)         TYPE(*CHAR) LEN(300) STG(*DEFINED) DEFVAR(&RAW_ROW 1)  
DCL     VAR(&CHAR_SIZE)   TYPE(*INT)  LEN(4)   VALUE(1) 
DCL     VAR(&COUNT)       TYPE(*INT)  LEN(4)  
DCL     VAR(&EFF_LEN)     TYPE(*INT)  LEN(4)  
DCL     VAR(&FILE_BUF_P)  TYPE(*PTR) 
INCLUDE SRCSTMF('FILE_P.CLLE')
CHGVAR  VAR(&NOMEFILE)  VALUE(&NOMEFILE *TCAT &NULL)
CHGVAR  VAR(&MODE)      VALUE(&MODE *TCAT &NULL)
CALLPRC PRC('fopen') PARM(&NOMEFILE &MODE) RTNVAL(&FILE_BUF_P)
CHGVAR VAR(&EFF_LEN) VALUE(&F01_BUFLEN - 12)
DOFOR VAR(&ROW_NO) FROM(1) TO(&F07_APPRRN)
  CALLPRC PRC('fread') PARM(&RAW_ROW (&CHAR_SIZE *BYVAL) (&EFF_LEN *BYVAL) (&FILE_BUF_P *BYVAL)) +
        RTNVAL(&COUNT)
  SNDPGMMSG MSG(%SST(&ROW 1 &EFF_LEN))
ENDDO
CALLPRC PRC('fclose') PARM((&FILE_BUF_P *BYVAL))
ENDPGM
:exmp.
:ehelp.

.* 19
:help name=m0option19.
Opzione 19: Uso open(), write() e close()
:xh3.Opzione 19: Uso open(), write() e close()
:p.
Ora al fianco di fopen(), fread() e fclose() introduciamo open(), write() e close().
Qui la concenzione per i nomi cambia: è quella dell'Integrated File System (IFS).
Con l'esempio copiamo un file sorgente nativo in un file su IFS.
:xmp.
PGM     PARM(&NOMEFILE)
DCL     VAR(&NOMEFILE)    TYPE(*CHAR) LEN(60)
DCL     VAR(&NOMEFILE_O)  TYPE(*CHAR) LEN(60)  VALUE('elaborato.bin')
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&MODE)        TYPE(*CHAR) LEN(11)  VALUE('rb')
DCL     VAR(&FLAG_O)      TYPE(*INT)  LEN(4)   VALUE(12)
DCL     VAR(&ROW_NO)      TYPE(*INT)  LEN(4)   VALUE(1)
DCL     VAR(&RAW_ROW)     TYPE(*CHAR) LEN(312) 
DCL     VAR(&ROW)         TYPE(*CHAR) LEN(300) STG(*DEFINED) DEFVAR(&RAW_ROW 1)  
DCL     VAR(&CHAR_SIZE)   TYPE(*INT)  LEN(4)   VALUE(1) 
DCL     VAR(&COUNT)       TYPE(*INT)  LEN(4)  
DCL     VAR(&EFF_LEN)     TYPE(*INT)  LEN(4)   VALUE(10)
DCL     VAR(&FD)          TYPE(*INT)  LEN(4)  
DCL     VAR(&FILE_BUF_P)  TYPE(*PTR) 
DCL     VAR(&ROW_P)       TYPE(*PTR)  ADDRESS(&RAW_ROW)
INCLUDE SRCSTMF('FILE_P.CLLE')
CHGVAR  VAR(&NOMEFILE)   VALUE(&NOMEFILE *TCAT &NULL)
CHGVAR  VAR(&NOMEFILE_O) VALUE(&NOMEFILE_O *TCAT &NULL)
CHGVAR  VAR(&MODE)       VALUE(&MODE *TCAT &NULL)
CALLPRC PRC('fopen') PARM(&NOMEFILE &MODE) RTNVAL(&FILE_BUF_P)
CALLPRC PRC('open')  PARM(&NOMEFILE_O (&FLAG_O *BYVAL)) RTNVAL(&FD)
SNDPGMMSG MSG(%CHAR(&FD))      
CHGVAR VAR(&EFF_LEN) VALUE(&F01_BUFLEN - 12) 
DOFOR VAR(&ROW_NO) FROM(1) TO(&F07_APPRRN)
  CALLPRC PRC('fread') PARM(&RAW_ROW (&CHAR_SIZE *BYVAL) (&EFF_LEN *BYVAL) (&FILE_BUF_P *BYVAL)) RTNVAL(&COUNT) 
  CALLPRC PRC('write') PARM((&FD *BYVAL) (&ROW_P *BYVAL) (&EFF_LEN *BYVAL) ) RTNVAL(&COUNT)
ENDDO 
CALLPRC PRC('close') PARM((&FD *BYVAL))
CALLPRC PRC('fclose') PARM((&FILE_BUF_P *BYVAL))
ENDPGM
:exmp.
:ehelp.

.* 20
:help name=m0option20.
Opzione 20: Uso open(), read() e close()
:xh3.Opzione 20: Uso open(), read() e close()
:p.
Qui accediamo ad un file avente record di lunghezza fissa (&amp.EFF_LEN).
Emettiamo i singoli record.
:xmp.
PGM     PARM(&NOMEFILE)
DCL     VAR(&NOMEFILE)    TYPE(*CHAR) LEN(60)
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&FLAG)        TYPE(*INT)  LEN(4)   VALUE(1)
DCL     VAR(&ROW_NO)      TYPE(*INT)  LEN(4)   VALUE(1)
DCL     VAR(&RAW_ROW)     TYPE(*CHAR) LEN(312) 
DCL     VAR(&ROW)         TYPE(*CHAR) LEN(300) STG(*DEFINED) DEFVAR(&RAW_ROW 1)  
DCL     VAR(&COUNT)       TYPE(*INT)  LEN(4)  
DCL     VAR(&EFF_LEN)     TYPE(*INT)  LEN(4)   VALUE(80)
DCL     VAR(&FD)          TYPE(*INT)  LEN(4)  
DCL     VAR(&ROW_P)       TYPE(*PTR)  ADDRESS(&RAW_ROW)
CHGVAR  VAR(&NOMEFILE)  VALUE(&NOMEFILE *TCAT &NULL)
CALLPRC PRC('open')  PARM(&NOMEFILE (&FLAG *BYVAL)) RTNVAL(&FD)
CALLPRC PRC('read') PARM((&FD *BYVAL) (&RAW_ROW) (&EFF_LEN *BYVAL) ) RTNVAL(&COUNT)
DOWHILE COND(&COUNT *GT 0)
  SNDPGMMSG MSG(%SST(&ROW 1 &EFF_LEN))
  CALLPRC PRC('read') PARM((&FD *BYVAL) (&RAW_ROW) (&EFF_LEN *BYVAL) ) RTNVAL(&COUNT)
ENDDO
CALLPRC PRC('close') PARM((&FD *BYVAL))
ENDPGM
:exmp.
:ehelp.

.* 21
:help name=m0option21.
Opzione 21: Primi 8 byte di un SAVF
:xh3.Opzione 21: Primi 8 byte di un SAVF
:p.
Qui impostiamo la lunghezza record a 528 e leggiamo un singolo record 
da un savefile: emettiamo il numero ottenuto interpretando come
unsigned integer di 8 byte i primi byte del savefile.
:xmp.
PGM     PARM(&NOMEFILE)
DCL     VAR(&NOMEFILE)    TYPE(*CHAR) LEN(60)
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&FLAG)        TYPE(*INT)  LEN(4)   VALUE(1)
DCL     VAR(&ROW_NO)      TYPE(*INT)  LEN(4)   VALUE(1)
DCL     VAR(&RAW_ROW)     TYPE(*CHAR) LEN(528) 
DCL     VAR(&ROW)         TYPE(*CHAR) LEN(512) STG(*DEFINED) DEFVAR(&RAW_ROW 1)  
DCL     VAR(&TS)          TYPE(*UINT) LEN(8)   STG(*DEFINED) DEFVAR(&ROW 1)  
DCL     VAR(&COUNT)       TYPE(*INT)  LEN(4)  
DCL     VAR(&EFF_LEN)     TYPE(*INT)  LEN(4)   VALUE(528)
DCL     VAR(&FD)          TYPE(*INT)  LEN(4)  
DCL     VAR(&ROW_P)       TYPE(*PTR)  ADDRESS(&RAW_ROW)
CHGVAR  VAR(&NOMEFILE)  VALUE(&NOMEFILE *TCAT &NULL)
CALLPRC PRC('open')  PARM(&NOMEFILE (&FLAG *BYVAL)) RTNVAL(&FD)
CALLPRC PRC('read') PARM((&FD *BYVAL) (&RAW_ROW) (&EFF_LEN *BYVAL) ) RTNVAL(&COUNT)
SNDPGMMSG MSG(%CHAR(&TS))
CALLPRC PRC('close') PARM((&FD *BYVAL))
ENDPGM
:exmp.
:ehelp.

.* 22
:help name=m0option22.
Opzione 22: Chiamata a "QWCCVTDT" (*DTS) 1
:xh3.Opzione 22: Chiamata a "QWCCVTDT" (*DTS) 1
:p.
Qui visualizziamo il codice messaggio per l'errore ottenuto 
invocando la "QWCCVTDT" (CALL) specificando un valore erroneo 
per il formato data/ora restituito.
:xmp.
PGM
DCL        VAR(&FORMAT_I)  TYPE(*CHAR) LEN(10) VALUE('*DTS')
DCL        VAR(&VAR_I)     TYPE(*CHAR) LEN(8) VALUE(X'8000000000000000')
DCL        VAR(&FORMAT_O)  TYPE(*CHAR) LEN(10) VALUE('*FAKE')
DCL        VAR(&VAR_O)     TYPE(*CHAR) LEN(20)
INCLUDE SRCSTMF('ERRCOD.CLLE')
CALL PGM(QWCCVTDT) PARM(&FORMAT_I +
                        &VAR_I   +
                        &FORMAT_O +
                        &VAR_O   +
                        &ERRCOD)
SNDPGMMSG MSG(&MSGID *BCAT &MSGDTA)
ENDPGM
:exmp.
:ehelp.

.* 23
:help name=m0option23.
Opzione 23: Chiamata a "QWCCVTDT" (*DTS) 2
:xh3.Opzione 23: Chiamata a "QWCCVTDT" (*DTS) 2
:p.
Ora chiediamo la conversione da *DTA a *YYMD
:xmp.
PGM
DCL        VAR(&FORMAT_I)  TYPE(*CHAR) LEN(10) VALUE('*DTS')
DCL        VAR(&VAR_I)     TYPE(*CHAR) LEN(8) VALUE(X'8000000000000000')
DCL        VAR(&FORMAT_O)  TYPE(*CHAR) LEN(10) VALUE('*YYMD')
DCL        VAR(&VAR_O)     TYPE(*CHAR) LEN(20)
DCL        VAR(&ANNO)      TYPE(*CHAR) STG(*DEFINED) LEN(4)    DEFVAR(&VAR_O  1)
DCL        VAR(&MESE)      TYPE(*CHAR) STG(*DEFINED) LEN(2)    DEFVAR(&VAR_O  5)
DCL        VAR(&GIORNO)    TYPE(*CHAR) STG(*DEFINED) LEN(2)    DEFVAR(&VAR_O  7)
INCLUDE SRCSTMF('ERRCOD.CLLE')
CALL PGM(QWCCVTDT) PARM(&FORMAT_I +
                        &VAR_I   +
                        &FORMAT_O +
                        &VAR_O   +
                        &ERRCOD)
IF COND(&BYTAVA *GT 0) THEN(SNDPGMMSG MSG(&MSGID *BCAT &MSGDTA))  
ELSE CMD(SNDPGMMSG MSG('Salvato il giorno' *BCAT &GIORNO *BCAT 'del' +
                        *BCAT &MESE *CAT '° mese dell''anno' *BCAT &ANNO))
ENDPGM
:exmp.
:ehelp.

.* 24
:help name=m0option24.
Opzione 24: Data creazione di un SAVF
:xh3.Opzione 24: Data creazione di un SAVF
:p.
Uniamo quato appreso nell'ultimo esempio per generare un messaggio circa la data 
di un timestamp.
:xmp.
PGM     PARM(&NOMEFILE)
DCL     VAR(&NOMEFILE)    TYPE(*CHAR) LEN(60)
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&FLAG)        TYPE(*INT)  LEN(4)   VALUE(1)
DCL     VAR(&ROW_NO)      TYPE(*INT)  LEN(4)   VALUE(1)
DCL     VAR(&RAW_ROW)     TYPE(*CHAR) LEN(528) 
DCL     VAR(&ROW)         TYPE(*CHAR) LEN(512) STG(*DEFINED) DEFVAR(&RAW_ROW 1)  
DCL     VAR(&TS)          TYPE(*UINT) LEN(8)   STG(*DEFINED) DEFVAR(&ROW  1)  
DCL     VAR(&NBRRECS)     TYPE(*INT)  LEN(4)   STG(*DEFINED) DEFVAR(&ROW  9)  
DCL     VAR(&VR1)         TYPE(*INT)  LEN(2)   STG(*DEFINED) DEFVAR(&ROW 11)  
DCL     VAR(&VR2)         TYPE(*INT)  LEN(2)   STG(*DEFINED) DEFVAR(&ROW 13)  
DCL     VAR(&F04)         TYPE(*INT)  LEN(2)   STG(*DEFINED) DEFVAR(&ROW 15)  
DCL     VAR(&DESC)        TYPE(*CHAR) LEN(32)  STG(*DEFINED) DEFVAR(&ROW 17)  
DCL     VAR(&COUNT)       TYPE(*INT)  LEN(4)  
DCL     VAR(&EFF_LEN)     TYPE(*INT)  LEN(4)   VALUE(528)
DCL     VAR(&FD)          TYPE(*INT)  LEN(4)  
DCL     VAR(&ROW_P)       TYPE(*PTR)  ADDRESS(&RAW_ROW)
DCL     VAR(&FORMAT_I)  TYPE(*CHAR) LEN(10) VALUE('*DTS')
DCL     VAR(&VAR_I)       TYPE(*CHAR) LEN(8)    
DCL     VAR(&TS2)         TYPE(*UINT) LEN(8)   STG(*DEFINED) DEFVAR(&VAR_I 1)  
DCL     VAR(&FORMAT_O)  TYPE(*CHAR) LEN(10) VALUE('*YYMD')
DCL     VAR(&VAR_O)     TYPE(*CHAR) LEN(20)
DCL     VAR(&ANNO)      TYPE(*CHAR) STG(*DEFINED) LEN(4)    DEFVAR(&VAR_O  1)
DCL     VAR(&MESE)      TYPE(*CHAR) STG(*DEFINED) LEN(2)    DEFVAR(&VAR_O  5)
DCL     VAR(&GIORNO)    TYPE(*CHAR) STG(*DEFINED) LEN(2)    DEFVAR(&VAR_O  7)
INCLUDE SRCSTMF('ERRCOD.CLLE')
CHGVAR  VAR(&NOMEFILE)  VALUE(&NOMEFILE *TCAT &NULL)
CALLPRC PRC('open')  PARM(&NOMEFILE (&FLAG *BYVAL)) RTNVAL(&FD)
CALLPRC PRC('read') PARM((&FD *BYVAL) (&RAW_ROW) (&EFF_LEN *BYVAL) ) RTNVAL(&COUNT)
CALLPRC PRC('close') PARM((&FD *BYVAL))
CHGVAR  VAR(&TS2) VALUE(&TS)
CALL PGM(QWCCVTDT) PARM(&FORMAT_I &VAR_I &FORMAT_O &VAR_O &ERRCOD)
IF COND(&BYTAVA *GT 0) THEN(SNDPGMMSG MSG(&MSGID *BCAT &MSGDTA))  
ELSE CMD(DO)
  SNDPGMMSG MSG('Salvato il giorno' *BCAT &GIORNO *BCAT 'del' +
                        *BCAT &MESE *CAT '° mese dell''anno' *BCAT &ANNO)
  SNDPGMMSG MSG('  Record . . . . . . . . . . . . . . . :' *BCAT %CHAR(&NBRRECS))                 
  SNDPGMMSG MSG(&DESC)
ENDDO                        
ENDPGM
:exmp.
:ehelp.

.* 25
:help name=m0option25.
Opzione 25: Uso di _Ropen() e _Rclose()
:xh3.Opzione 25: Uso di _Ropen() e _Rclose()
:p.
Ora utilizziamo _Ropen() e _Rclose(). 
Sfruttiamo la "DMPCLPGM" per conoscere il contenuto di &amp.RFILE.
:xmp.
PGM     PARM(&FILENAME)
DCL     VAR(&FILENAME)    TYPE(*CHAR) LEN(60)
DCL     VAR(&MODE)        TYPE(*CHAR) LEN(11)  VALUE('rr')
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&FP)          TYPE(*PTR)  ADDRESS(*NULL)
DCL     VAR(&RFILE)       TYPE(*CHAR) LEN(336) STG(*BASED)  BASPTR(&FP)
CHGVAR  VAR(&FILENAME)  VALUE(&FILENAME *TCAT &NULL)
CHGVAR  VAR(&MODE)      VALUE(&MODE *TCAT &NULL)
CALLPRC PRC('_Ropen')   PARM(&FILENAME &MODE) RTNVAL(&FP)
DMPCLPGM
CALLPRC PRC('_Rclose')  PARM((&FP *BYVAL))
ENDPGM
:exmp.
:ehelp.

.* 26
:help name=m0option26.
Opzione 26: Uso struttura _RFILE
:xh3.Opzione 26: Uso struttura _RFILE
:p.
Ora includiamo il dettaglio dei campi dell'_RFILE.
:xmp.
PGM     PARM(&FILENAME)
DCL     VAR(&FILENAME)    TYPE(*CHAR) LEN(60)
DCL     VAR(&MODE)        TYPE(*CHAR) LEN(11)  VALUE('rr')
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&FP)          TYPE(*PTR)  ADDRESS(*NULL)
INCLUDE SRCSTMF('RFILE_P.CLLE')
CHGVAR  VAR(&FILENAME)  VALUE(&FILENAME *TCAT &NULL)
CHGVAR  VAR(&MODE)      VALUE(&MODE *TCAT &NULL)
CALLPRC PRC('_Ropen')   PARM(&FILENAME &MODE) RTNVAL(&FP)
DMPCLPGM
CALLPRC PRC('_Rclose')  PARM((&FP *BYVAL))
ENDPGM
:exmp.
:ehelp.

.* 27
:help name=m0option27.
Opzione 27: Ciclo di _Rreadn() 
:xh3.Opzione 27: Ciclo di _Rreadn() 
:p.
Con il presente modulo scorriamo il contenuto del file sorgente.
All'apertura del file valorizziamo la variabile &amp.EFF_LEN al 
valore della lunghezza record utile ( di fatto sottraendo 12 a &amp.F10_BUFLEN).
Si noti che &amp.ROW è STG(*DEFINED) DEFVAR(&amp.RAW_ROW 13). 
:xmp.
PGM     PARM(&FILENAME)
DCL     VAR(&FILENAME)    TYPE(*CHAR) LEN(60)
DCL     VAR(&MODE)        TYPE(*CHAR) LEN(11)  VALUE('rr')
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&FP)          TYPE(*PTR)  ADDRESS(*NULL)
INCLUDE SRCSTMF('RFILE_P.CLLE')
DCL     VAR(&RIOFB_P)     TYPE(*PTR)  ADDRESS(*NULL)
INCLUDE SRCSTMF('RIOFB_P.CLLE')
DCL     VAR(&RAW_ROW)     TYPE(*CHAR) LEN(312) 
DCL     VAR(&ROW)         TYPE(*CHAR) LEN(300) STG(*DEFINED) DEFVAR(&RAW_ROW 13)  
DCL     VAR(&OPTS)        TYPE(*INT)  LEN(4)   VALUE(0)
DCL     VAR(&EFF_LEN)     TYPE(*INT)  LEN(4)   VALUE(-12)
CHGVAR  VAR(&FILENAME)  VALUE(&FILENAME *TCAT &NULL)
CHGVAR  VAR(&MODE)      VALUE(&MODE *TCAT &NULL)
CALLPRC PRC('_Ropen')   PARM(&FILENAME &MODE) RTNVAL(&FP)
CHGVAR  VAR(&EFF_LEN)   VALUE(&EFF_LEN + &F10_BUFLEN) 
CALLPRC PRC('_Rreadn')  PARM((&FP *BYVAL) &RAW_ROW (&F10_BUFLEN *BYVAL) (&OPTS *BYVAL)) RTNVAL(&RIOFB_P)
DOWHILE COND(&F06_NUMBYT *NE -1)
  SNDPGMMSG MSG(%SST(&ROW 1 &EFF_LEN))
  CALLPRC PRC('_Rreadn')  PARM((&FP *BYVAL) &RAW_ROW (&F10_BUFLEN *BYVAL) (&OPTS *BYVAL)) RTNVAL(&RIOFB_P)
ENDDO
CALLPRC PRC('_Rclose')  PARM((&FP *BYVAL))
ENDPGM
:exmp.
:ehelp.

.* 28
:help name=m0option28.
Opzione 28: Con SRCSEQ e SRCDAT
:xh3.Opzione 28: Con SRCSEQ e SRCDAT
:p.
Con le chiamate _R*() accediamo al record nella loro totalità.
Possiamo dunque valorizzare anche SRCSEQ e SRCDAT.
:xmp.
PGM     PARM(&FILENAME)
DCL     VAR(&FILENAME)    TYPE(*CHAR) LEN(60)
DCL     VAR(&MODE)        TYPE(*CHAR) LEN(11)  VALUE('rr')
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&FP)          TYPE(*PTR)  ADDRESS(*NULL)
INCLUDE SRCSTMF('RFILE_P.CLLE')
DCL     VAR(&RIOFB_P)     TYPE(*PTR)  ADDRESS(*NULL)
INCLUDE SRCSTMF('RIOFB_P.CLLE')
DCL     VAR(&RAW_ROW)     TYPE(*CHAR) LEN(312) 
DCL     VAR(&SRCSEQ)      TYPE(*CHAR) LEN(6)   STG(*DEFINED) DEFVAR(&RAW_ROW  1)  
DCL     VAR(&SRCDAT)      TYPE(*CHAR) LEN(6)   STG(*DEFINED) DEFVAR(&RAW_ROW  7)  
DCL     VAR(&SRCDTA)      TYPE(*CHAR) LEN(300) STG(*DEFINED) DEFVAR(&RAW_ROW 13)  
DCL     VAR(&OPTS)        TYPE(*INT)  LEN(4)   VALUE(0)
DCL     VAR(&EFF_LEN)     TYPE(*INT)  LEN(4)   VALUE(-12)
CHGVAR  VAR(&FILENAME)  VALUE(&FILENAME *TCAT &NULL)
CHGVAR  VAR(&MODE)      VALUE(&MODE *TCAT &NULL)
CALLPRC PRC('_Ropen')   PARM(&FILENAME &MODE) RTNVAL(&FP)
CHGVAR  VAR(&EFF_LEN)   VALUE(&EFF_LEN + &F10_BUFLEN) 
CALLPRC PRC('_Rreadn')  PARM((&FP *BYVAL) &RAW_ROW (&F10_BUFLEN *BYVAL) (&OPTS *BYVAL)) RTNVAL(&RIOFB_P)
DOWHILE COND(&F06_NUMBYT *NE -1)
  SNDPGMMSG MSG(%SST(&SRCSEQ 1 4) *CAT '.' *CAT %SST(&SRCSEQ 5 2) *CAT ' ' +
           *CAT %SST(&SRCDTA 1 &EFF_LEN) *CAT ' ' *CAT &SRCDAT)
  CALLPRC PRC('_Rreadn')  PARM((&FP *BYVAL) &RAW_ROW (&F10_BUFLEN *BYVAL) (&OPTS *BYVAL)) RTNVAL(&RIOFB_P)
ENDDO
CALLPRC PRC('_Rclose')  PARM((&FP *BYVAL))
ENDPGM
:exmp.
:ehelp.

.* 29
:help name=m0option29.
Opzione 29: DB file creato con SQL
:xh3.Opzione 29: DB file creato con SQL
:p.
Con le chiamate _R*() accediamo anche ai file creati con SQL.
Sta a noi l'onere di specificare i sotto-campi del record.
:xmp.
PGM     PARM(&FILENAME)
DCL     VAR(&FILENAME)    TYPE(*CHAR) LEN(60)
DCL     VAR(&MODE)        TYPE(*CHAR) LEN(11)  VALUE('rr')
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&FP)          TYPE(*PTR)  ADDRESS(*NULL)
INCLUDE SRCSTMF('RFILE_P.CLLE')
DCL     VAR(&RIOFB_P)     TYPE(*PTR)  ADDRESS(*NULL)
INCLUDE SRCSTMF('RIOFB_P.CLLE')
DCL     VAR(&RAW_ROW)     TYPE(*CHAR) LEN(312) 
/* */
DCL     VAR(&EMPNO)       TYPE(*CHAR) LEN(6)   STG(*DEFINED) DEFVAR(&RAW_ROW  1)  
DCL     VAR(&FIRSTNME_L)  TYPE(*INT)  LEN(2)   STG(*DEFINED) DEFVAR(&RAW_ROW  7)  
DCL     VAR(&FIRSTNME)    TYPE(*CHAR) LEN(12)  STG(*DEFINED) DEFVAR(&RAW_ROW  9)  
DCL     VAR(&MIDINIT)     TYPE(*CHAR) LEN(1)   STG(*DEFINED) DEFVAR(&RAW_ROW 21)  
DCL     VAR(&LASTNAME_L)  TYPE(*INT)  LEN(2)   STG(*DEFINED) DEFVAR(&RAW_ROW 22)  
DCL     VAR(&LASTNAME)    TYPE(*CHAR) LEN(15)  STG(*DEFINED) DEFVAR(&RAW_ROW 24)  
DCL     VAR(&WORKDEPT)    TYPE(*CHAR) LEN(3)   STG(*DEFINED) DEFVAR(&RAW_ROW 39)  
DCL     VAR(&PHONENO)     TYPE(*CHAR) LEN(4)   STG(*DEFINED) DEFVAR(&RAW_ROW 42)  
DCL     VAR(&HIREDATE)    TYPE(*CHAR) LEN(10)  STG(*DEFINED) DEFVAR(&RAW_ROW 46)  
DCL     VAR(&JOB)         TYPE(*CHAR) LEN(8)   STG(*DEFINED) DEFVAR(&RAW_ROW 56)  
DCL     VAR(&EDLEVEL)     TYPE(*INT)  LEN(2)   STG(*DEFINED) DEFVAR(&RAW_ROW 64)  
DCL     VAR(&SEX)         TYPE(*CHAR) LEN(1)   STG(*DEFINED) DEFVAR(&RAW_ROW 66)  
DCL     VAR(&BIRTHDATE)   TYPE(*CHAR) LEN(10)  STG(*DEFINED) DEFVAR(&RAW_ROW 67)  
DCL     VAR(&SALARY)      TYPE(*DEC)  LEN(9 2) STG(*DEFINED) DEFVAR(&RAW_ROW 77)  
DCL     VAR(&BONUS)       TYPE(*DEC)  LEN(9 2) STG(*DEFINED) DEFVAR(&RAW_ROW 82)  
DCL     VAR(&COMM)        TYPE(*DEC)  LEN(9 2) STG(*DEFINED) DEFVAR(&RAW_ROW 87)  
/* */
DCL     VAR(&EDLEVEL_C)   TYPE(*CHAR) LEN(6)
DCL     VAR(&SALARY_C)    TYPE(*CHAR) LEN(11)
DCL     VAR(&BONUS_C)     TYPE(*CHAR) LEN(11)  
DCL     VAR(&COMM_C)      TYPE(*CHAR) LEN(11)  
DCL     VAR(&OPTS)        TYPE(*INT)  LEN(4)   VALUE(0)
CHGVAR  VAR(&FILENAME)  VALUE(&FILENAME *TCAT &NULL)
CHGVAR  VAR(&MODE)      VALUE(&MODE *TCAT &NULL)
CALLPRC PRC('_Ropen')   PARM(&FILENAME &MODE) RTNVAL(&FP)
CALLPRC PRC('_Rreadn')  PARM((&FP *BYVAL) &RAW_ROW (&F10_BUFLEN *BYVAL) (&OPTS *BYVAL)) RTNVAL(&RIOFB_P)
DOWHILE COND(&F06_NUMBYT *NE -1)
  CHGVAR VAR(&EDLEVEL_C) VALUE(%CHAR(&EDLEVEL))
  CHGVAR VAR(&SALARY_C)  VALUE(%CHAR(&SALARY))
  CHGVAR VAR(&BONUS_C)   VALUE(%CHAR(&BONUS))
  CHGVAR VAR(&COMM_C)    VALUE(%CHAR(&COMM))
  SNDPGMMSG MSG('''' *CAT &EMPNO *CAT ''':''' *CAT %SST(&FIRSTNME 1 &FIRSTNME_L) *CAT ''':''' +
                     *CAT &MIDINIT *CAT ''':''' *CAT %SST(&LASTNAME 1 &LASTNAME_L)  *CAT ''':''' +
                     *CAT &WORKDEPT *CAT ''':''' *CAT &PHONENO *CAT ''':' + 
                     *CAT &HIREDATE *CAT ':''' *CAT %TRIM(&JOB) *CAT ''':' + 
                     *CAT %TRIM(&EDLEVEL_C) *CAT ':''' *CAT &SEX *CAT ''':' +
                     *CAT &BIRTHDATE *CAT ':' *CAT %TRIM(&SALARY_C) *CAT ':' +
                     *CAT %TRIM(&BONUS_C) *CAT ':' *CAT %TRIM(&COMM_C))
  CALLPRC PRC('_Rreadn')  PARM((&FP *BYVAL) &RAW_ROW (&F10_BUFLEN *BYVAL) (&OPTS *BYVAL)) RTNVAL(&RIOFB_P)
ENDDO
CALLPRC PRC('_Rclose')  PARM((&FP *BYVAL))
ENDPGM
:exmp.
:ehelp.

.* 30
:help name=m0option30.
Opzione 30: DB _Rwrite()/_Rcommit()
:xh3.Opzione 30: DB _Rwrite()/_Rcommit()
:p.
Inseriamo un nuovo record con _Rwrite(). 
Fondamentale impostare correttamente il &amp.MODE indicando
la modalità e il commitment control. 
.* :xmp.
.* PGM     PARM(&FILENAME)
.* DCL     VAR(&FILENAME)    TYPE(*CHAR) LEN(60)
.* DCL     VAR(&MODE)        TYPE(*CHAR) LEN(32)  VALUE('ar+,commit=y')
.* DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
.* DCL     VAR(&MSG)         TYPE(*CHAR) LEN(30)  VALUE('Registrazione completata') 
.* DCL     VAR(&FP)          TYPE(*PTR)  ADDRESS(*NULL)
.* INCLUDE SRCSTMF('RFILE_P.CLLE')
.* DCL     VAR(&RIOFB_P)     TYPE(*PTR)  ADDRESS(*NULL)
.* INCLUDE SRCSTMF('RIOFB_P.CLLE')
.* DCL     VAR(&RAW_ROW)     TYPE(*CHAR) LEN(312) 
.* DCL     VAR(&EMPNO)       TYPE(*CHAR) LEN(6)   STG(*DEFINED) DEFVAR(&RAW_ROW  1)  
.* DCL     VAR(&FIRSTNME_L)  TYPE(*INT)  LEN(2)   STG(*DEFINED) DEFVAR(&RAW_ROW  7)  
.* DCL     VAR(&FIRSTNME)    TYPE(*CHAR) LEN(12)  STG(*DEFINED) DEFVAR(&RAW_ROW  9)  
.* DCL     VAR(&MIDINIT)     TYPE(*CHAR) LEN(1)   STG(*DEFINED) DEFVAR(&RAW_ROW 21)  
.* DCL     VAR(&LASTNAME_L)  TYPE(*INT)  LEN(2)   STG(*DEFINED) DEFVAR(&RAW_ROW 22)  
.* DCL     VAR(&LASTNAME)    TYPE(*CHAR) LEN(15)  STG(*DEFINED) DEFVAR(&RAW_ROW 24)  
.* DCL     VAR(&WORKDEPT)    TYPE(*CHAR) LEN(3)   STG(*DEFINED) DEFVAR(&RAW_ROW 39)  
.* DCL     VAR(&PHONENO)     TYPE(*CHAR) LEN(4)   STG(*DEFINED) DEFVAR(&RAW_ROW 42)  
.* DCL     VAR(&HIREDATE)    TYPE(*CHAR) LEN(10)  STG(*DEFINED) DEFVAR(&RAW_ROW 46)  
.* DCL     VAR(&JOB)         TYPE(*CHAR) LEN(8)   STG(*DEFINED) DEFVAR(&RAW_ROW 56)  
.* DCL     VAR(&EDLEVEL)     TYPE(*INT)  LEN(2)   STG(*DEFINED) DEFVAR(&RAW_ROW 64)  
.* DCL     VAR(&SEX)         TYPE(*CHAR) LEN(1)   STG(*DEFINED) DEFVAR(&RAW_ROW 66)  
.* DCL     VAR(&BIRTHDATE)   TYPE(*CHAR) LEN(10)  STG(*DEFINED) DEFVAR(&RAW_ROW 67)  
.* DCL     VAR(&SALARY)      TYPE(*DEC)  LEN(9 2) STG(*DEFINED) DEFVAR(&RAW_ROW 77)  
.* DCL     VAR(&BONUS)       TYPE(*DEC)  LEN(9 2) STG(*DEFINED) DEFVAR(&RAW_ROW 82)  
.* DCL     VAR(&COMM)        TYPE(*DEC)  LEN(9 2) STG(*DEFINED) DEFVAR(&RAW_ROW 87)  
.* CHGVAR  VAR(&FILENAME)  VALUE(&FILENAME *TCAT &NULL)
.* CHGVAR  VAR(&MODE)      VALUE(&MODE *TCAT &NULL)
.* STRCMTCTL LCKLVL(*ALL)
.* CALLPRC PRC('_Ropen')   PARM(&FILENAME &MODE) RTNVAL(&FP)
.* CHGVAR  VAR(&EMPNO) VALUE('300101')
.* CHGVAR  VAR(&FIRSTNME_L) VALUE(6)
.* CHGVAR  VAR(&FIRSTNME)   VALUE('ANDREA')
.* CHGVAR  VAR(&MIDINIT)    VALUE(' ')
.* CHGVAR  VAR(&LASTNAME_L) VALUE(7)
.* CHGVAR  VAR(&LASTNAME)   VALUE('RIBUOLI')
.* CHGVAR  VAR(&WORKDEPT)   VALUE('A00')
.* CHGVAR  VAR(&PHONENO)    VALUE('8696')
.* CHGVAR  VAR(&HIREDATE)   VALUE('2025-03-29')
.* CHGVAR  VAR(&JOB)        VALUE('PRES')
.* CHGVAR  VAR(&EDLEVEL)    VALUE(18)
.* CHGVAR  VAR(&SEX)        VALUE('M')
.* CHGVAR  VAR(&BIRTHDATE)  VALUE('1962-04-27')
.* CHGVAR  VAR(&SALARY)     VALUE(37000)
.* CHGVAR  VAR(&BONUS)      VALUE(2000)
.* CHGVAR  VAR(&COMM)       VALUE(700)
.* CALLPRC PRC('_Rwrite')   PARM((&FP *BYVAL) &RAW_ROW (&F10_BUFLEN *BYVAL)) RTNVAL(&RIOFB_P)
.* DMPCLPGM
.* CALLPRC PRC('_Rcommit')  PARM(&MSG)
.* CALLPRC PRC('_Rclose')   PARM((&FP *BYVAL))
.* ENDPGM
.* :exmp.
:ehelp.

.* 31
:help name=m0option31.
Opzione 31: DB uso di _Rupdate()
:xh3.Opzione 31: DB uso di _Rupdate()
:p.
Con questo esempio mofichiamo un sorgente rimpiazzando le 
righe di INCLUDE che specificano uno SRCSTMF in righe 
che adottino un SRCMBR.
:xmp.
PGM     PARM(&QTMPMBR)
DCL     VAR(&QTMPMBR)     TYPE(*CHAR) LEN(60)
DCL     VAR(&NULL)        TYPE(*CHAR) LEN(1)   VALUE(X'00')
DCL     VAR(&IMODE)       TYPE(*CHAR) LEN(11)  VALUE('rr+')
DCL     VAR(&DOT)         TYPE(*CHAR) LEN(1)   VALUE('.')
DCL     VAR(&EPOS)        TYPE(*INT)  LEN(2)
DCL     VAR(&FP)          TYPE(*PTR)  ADDRESS(*NULL)
INCLUDE SRCSTMF('RFILE_P.CLLE')
DCL     VAR(&RIOFB_P)     TYPE(*PTR)  ADDRESS(*NULL)
INCLUDE SRCSTMF('RIOFB_P.CLLE')
DCL     VAR(&RAW_ROW)     TYPE(*CHAR) LEN(312) 
DCL     VAR(&SRCDTA)      TYPE(*CHAR) LEN(300) STG(*DEFINED) DEFVAR(&RAW_ROW 13)  
DCL     VAR(&OPTS)        TYPE(*INT)  LEN(4)   VALUE(0)
CHGVAR  VAR(&QTMPMBR)    VALUE(&QTMPMBR *TCAT &NULL)
CHGVAR  VAR(&IMODE)      VALUE(&IMODE *TCAT &NULL)
CALLPRC PRC('_Ropen')   PARM(&QTMPMBR &IMODE) RTNVAL(&FP)
CALLPRC PRC('_Rreadn')  PARM((&FP *BYVAL) &RAW_ROW (&F10_BUFLEN *BYVAL) (&OPTS *BYVAL)) RTNVAL(&RIOFB_P)
DOWHILE COND(&F06_NUMBYT *NE -1)
  CHGVAR VAR(&SRCDTA) VALUE(%TRIML(&SRCDTA))
  IF (%SST(&SRCDTA 1 17) *EQ 'INCLUDE SRCSTMF(''') THEN(DO)
    CHGVAR VAR(&EPOS) VALUE(%SCAN(&DOT &SRCDTA 18))
    IF COND(&EPOS *GT 0) THEN(DO)
      CHGVAR VAR(&EPOS) VALUE(&EPOS - 18)
      CHGVAR VAR(&SRCDTA) VALUE('INCLUDE SRCMBR(' *CAT %SST(&SRCDTA 18 &EPOS) *CAT ')')
      CALLPRC PRC('_Rupdate') PARM((&FP *BYVAL) &RAW_ROW (&F10_BUFLEN *BYVAL)) RTNVAL(&RIOFB_P)
    ENDDO  
  ENDDO
  CALLPRC PRC('_Rreadn')  PARM((&FP *BYVAL) &RAW_ROW (&F10_BUFLEN *BYVAL) (&OPTS *BYVAL)) RTNVAL(&RIOFB_P)
ENDDO
CALLPRC PRC('_Rclose')  PARM((&FP *BYVAL))
ENDPGM
:exmp.
:ehelp.

.* 32
:help name=m0option32.
Opzione 32: Uso di getcwd()
:xh3.Opzione 32: Uso di getcwd()
:p.
Molto semplicemente uso la getcwd() per visualizzare la directory corrente. 
:xmp.
PGM    
DCL     VAR(&CURPATH)     TYPE(*CHAR) LEN(512)
DCL     VAR(&SIZE)        TYPE(*INT)  LEN(4)   VALUE(512)
DCL     VAR(&PTR)         TYPE(*PTR)  ADDRESS(*NULL)
CALLPRC PRC('getcwd')   PARM(&CURPATH (&SIZE *BYVAL)) RTNVAL(&PTR)
SNDPGMMSG MSG(&CURPATH)
ENDPGM
:exmp.
:ehelp.

.*
:help name=m0option99.
Opzione 99: Controlla cartella sviluppo
:xh3.Opzione 99: Controlla cartella sviluppo
:p.
Visualizza i soli file ILE CL presenti nella cartella IFS standard.
:ehelp.
.*
:epnlgrp.
